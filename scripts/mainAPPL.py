import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from tkinter import *
from sklearn.preprocessing import MinMaxScaler

window = Tk()
window.title('STOCK PREDICTION GRAPHS')
apple_stock_data = pd.read_csv('/Users/eminn/PycharmProjects/stockPricePredictions/data/APPL.csv')

"""
This code block formats the apple_stock_data
variable into a table that can be used to 
extract the columns with the information that we need,
such as Date, Open Price, and Close Price.
"""
apple_stock_data = apple_stock_data[['Date', 'Open', 'Close']]
apple_stock_data['Date'] = pd.to_datetime(apple_stock_data['Date'].apply(lambda x : x.split()[0]))
apple_stock_data.set_index('Date', drop=True, inplace=True)
# print(apple_stock_data.head())

"""
method to print the real-data opening
stock prices of APPL in a graph.
will compare this graph to the graph
of the open stock prices generated by
the neural network. 
"""
def printInitialOpenStockPrices():
    figure, ax = plt.subplots(1, 2, figsize=(20, 7))
    chart_type = FigureCanvasTkAgg(figure, window)
    chart_type.get_tk_widget().pack()
    ax[0].plot(apple_stock_data['Open'], label='Open', color='green')
    ax[0].set_xlabel('Date', size=15)
    ax[0].set_ylabel('Price', size=15)
    ax[0].legend()
    window.mainloop()
"""
method to print the real-data closing
stock prices of APPL in a graph.
will compare this graph to the graph
of the closing stock prices generated by
the neural network. 
"""
def printInitialCloseStockPrices():
    figure, ax = plt.subplots(1, 2, figsize=(20, 7))
    chart_type = FigureCanvasTkAgg(figure, window)
    chart_type.get_tk_widget().pack();
    ax[1].plot(apple_stock_data['Close'], label='Close', color='blue')
    ax[1].set_xlabel('Date', size=15)
    ax[1].set_ylabel('Price', size=16)
    ax[1].legend()
    window.mainloop()

# printInitialOpenStockPrices()
# printInitialCloseStockPrices()

MMS = MinMaxScaler()
apple_stock_data[apple_stock_data.columns] = MMS.fit_transform(apple_stock_data)
print(apple_stock_data.shape)

training_size = round(len(apple_stock_data) * 0.80) #Selecting 80% of the data for training and leaving the remaining for testing
train_data = apple_stock_data[:training_size] #The specific data to use to train the model
test_data = apple_stock_data[training_size:]  #the specific data to use to test the model

"""
Function to create sequences of data to use
for training and testing.
"""


def create_sequence(dataset):
    sequences = []
    labels = []
    start_index = 0

    for stop_index in range(25, len(dataset)): #selecting 25 rows at a time
        sequences.append(dataset.iloc[start_index:stop_index])
        labels.append(dataset.iloc[stop_index])
        start_index += 1
    return (np.array(sequences), np.array(labels))

train_sequence, train_label = create_sequence(train_data)
test_sequence, test_label = create_sequence(test_data)

print(train_sequence.shape, train_label.shape, test_sequence.shape, test_label.shape)
